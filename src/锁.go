/*
接着介绍一下锁操作，我们在Golang中常用的锁——互斥锁（Lock）和读写锁（RWLock），
互斥锁和读写锁的区别是：互斥锁无论是读操作还是写操作都会对目标加锁也就是说所有的操作都需要排队进行，
读写锁是加锁后写操作只能排队进行但是可以并发进行读操作，要注意一点就是读的时候写操作是阻塞的，写操作进行的时候读操作是阻塞的。
类型sync.Mutex/sync.RWMutex的零值表示了未被锁定的互斥量。也就是说，它是一个开箱即用的工具。
只需对它进行简单声明就可以正常使用了，例如（在这里以Mutex为例，相对于RWMutex也是同理）：
*/

/*
BenchmarkUseMutex-4   	100000000	        17.9 ns/op
BenchmarkUseChan-4    	20000000	        66.2 ns/op
PASS
ok  	_/golang/bench/mutex_chan	3.239s

根据上面的压测结果来看, 使用加锁的方式性能是使用 channel 的方式性能的 3.6倍 左右, 这个数值可不低啊. 所以在做服务端开发的时候, 对性能有所疑惑的时候一定要自己做一下 benchmark, 不能人云亦云.
*/