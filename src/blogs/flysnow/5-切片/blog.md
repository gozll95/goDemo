# 前言
切片也是一种数据结构，它和数组非常相似，因为他是围绕动态数组的概念设计的，可以按需自动改变大小，使用这种结构，可以更方便的管理和使用数据集合。

# 内部实现
切片是基于数组实现的，它的***底层是数组，它自己本身非常小***，可以理解为对底层数组的抽象。因为机遇数组实现，所以它的底层的内存是连续非配的，***效率非常高***，还可以通过索引获得数据，可以***迭代***以及***垃圾回收优化***的好处。

切片对象非常小，是因为它是只有3个字段的数据结构：***一个是指向底层数组的指针，一个是切片的长度，一个是切片的容量***。这3个字段，就是Go语言操作底层数组的元数据，有了它们，我们就可以任意的操作切片了。


# 声明和初始化
```
slice:=make([]int,5,10)
```

这时，我们创建的切片长度是5，容量是10,需要注意的这个容量10其实对应的是切片底层数组的。

因为切片的底层是数组，所以创建切片时，如果不指定字面值的话，默认值就是数组的元素的零值。这里我们所以指定了容量是10，但是我们职能访问5个元素，因为切片的长度是5，剩下的5个元素，需要切片扩充后才可以访问。

***(容量必须>=长度，我们是不能创建长度大于容量的切片的。)***

***(切片只能访问到其长度内的元素，访问超过长度外的元素，会导致运行时异常，与切片容量关联的元素只能用于切片增长。)***


我们前面讲了，切片算是一个动态数组，所以它可以按需增长，我们使用内置append函数即可。append函数可以为一个切片追加一个元素，至于如何增加、返回的是原切片还是一个新切片、长度和容量如何改变这些细节，append函数都会帮我们自动处理。


```
slice := []int{1, 2, 3, 4, 5}
newSlice := slice[1:3]
	
newSlice=append(newSlice,10)
fmt.Println(newSlice)
fmt.Println(slice)
//Output
[2 3 10]
[1 2 3 10 5]
```


例子中，通过append函数为新创建的切片newSlice,追加了一个元素10，我们发现打印的输出，原切片slice的第4个值也被改变了，变成了10。引起这种结果的原因是因为 ***newSlice有可用的容量*** ，***不会创建新的切片来满足追加*** ，所以直接在newSlice后追加了一个元素10，因为newSlice和slice切片***共用一个底层数组***，所以切片slice的对应的元素值也被改变了。

这里newSlice新追加的第3个元素，其实对应的是slice的第4个元素，所以这里的追加其实是把底层数组的第4个元素修改为10，然后把newSlice长度调整为3。

***(如果切片的底层数组，没有足够的容量时，就会新建一个底层数组，把原来数组的值复制到新底层数组里，再追加新值，这时候就不会影响原来的底层数组了。)***


***(所以一般我们在创建新切片的时候，最好要让新切片的长度和容量一样，这样我们在追加操作的时候就会生成新的底层数组，和原有数组分离，就不会因为共用底层数组而引起奇怪问题,因为共用数组的时候修改内容，会影响多个切片。)***


# 在函数间传递切片

我们知道切片是3个字段构成的结构类型，所以在函数间以值的方式传递的时候，占用的内存非常小，成本很低。在传递复制切片的时候，其底层数组不会被复制，也不会受影响，复制只是复制的切片本身，不涉及底层数组。

值传递,但是第一个元素是指向底层数组的指针

```
func main() {
	slice := []int{1, 2, 3, 4, 5}
	fmt.Printf("%p\n", &slice)
	modify(slice)
	fmt.Println(slice)
}
func modify(slice []int) {
	fmt.Printf("%p\n", &slice)
	slice[1] = 10
}
```

打印的输出如下：
```
0xc420082060
0xc420082080
[1 10 3 4 5]
```

仔细看，这两个切片的地址不一样，***所以可以确认切片在函数间传递是复制的***。而我们修改一个索引的值后，***发现原切片的值也被修改了***，说明它们共用一个底层数组。

在函数间传递切片非常高效，而且不需要传递指针和处理复杂的语法，只需要复制切片，然后根据自己的业务修改，最后传递回一个新的切片副本即可，这也是为什么函数间传递参数，使用切片，而不是数组的原因。

关于多维切片就不介绍了，还有多维数组，一来它和普通的切片数组一样，只不过是多个一维组成的多维；二来我压根不推荐用多维切片和数组，可读性不好，结构不够清晰，容易出问题。

